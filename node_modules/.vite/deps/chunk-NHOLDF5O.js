import {
  useDebounceFn,
  useDefaults,
  useFocus,
  useToNumber,
  withBvnPrefix
} from "./chunk-4QKW6AK6.js";
import {
  computed,
  createElementBlock,
  defineComponent,
  mergeModels,
  nextTick,
  normalizeClass,
  onActivated,
  onMounted,
  openBlock,
  ref,
  toValue,
  unref,
  useId,
  useModel
} from "./chunk-EAUNOWDZ.js";

// node_modules/bootstrap-vue-next/dist/useAriaInvalid-BTUbGj3Y.mjs
var useAriaInvalid = (ariaInvalid, state) => computed(() => {
  const resolvedAriaInvalid = toValue(ariaInvalid);
  const resolvedState = toValue(state);
  const resolvedAriaInvalidValue = resolvedAriaInvalid === true ? "true" : typeof resolvedAriaInvalid === "string" ? resolvedAriaInvalid : resolvedState === false ? "true" : resolvedAriaInvalid === false ? "false" : void 0;
  return resolvedAriaInvalidValue;
});

// node_modules/bootstrap-vue-next/dist/useId-BHgDiJzr.mjs
var useId2 = (id, suffix) => {
  const genId = useId();
  return computed(() => toValue(id) || withBvnPrefix(genId || "", suffix));
};

// node_modules/bootstrap-vue-next/dist/useFormInput-BOUK4K4H.mjs
var normalizeInput = (v, modelModifiers) => {
  if (v === null) return;
  let update = v;
  if (modelModifiers.number && typeof update === "string" && update !== "") {
    const parsed = Number.parseFloat(update);
    update = Number.isNaN(parsed) ? update : parsed;
  }
  return update;
};
var useFormInput = (props, modelValue, modelModifiers) => {
  const input = ref(null);
  const forceUpdateKey = ref(0);
  const computedId = useId2(() => props.id, "input");
  const debounceNumber = useToNumber(() => props.debounce ?? 0);
  const debounceMaxWaitNumber = useToNumber(() => props.debounceMaxWait ?? NaN);
  const internalUpdateModelValue = useDebounceFn(
    (value) => {
      modelValue.value = value;
    },
    () => modelModifiers.lazy === true ? 0 : debounceNumber.value,
    { maxWait: () => modelModifiers.lazy === true ? NaN : debounceMaxWaitNumber.value }
  );
  const updateModelValue = (value, force = false) => {
    if (modelModifiers.lazy === true && force === false) return;
    internalUpdateModelValue(value);
  };
  const { focused } = useFocus(input, {
    initialValue: props.autofocus
  });
  const _formatValue = (value, evt, force = false) => {
    if (props.formatter !== void 0 && (!props.lazyFormatter || force)) {
      return props.formatter(value, evt);
    }
    return value;
  };
  onMounted(() => {
    var _a;
    if (input.value) {
      input.value.value = ((_a = modelValue.value) == null ? void 0 : _a.toString()) ?? "";
    }
  });
  onActivated(() => {
    nextTick(() => {
      if (props.autofocus) {
        focused.value = true;
      }
    });
  });
  const computedAriaInvalid = useAriaInvalid(
    () => props.ariaInvalid,
    () => props.state
  );
  const onInput = (evt) => {
    const { value } = evt.target;
    const formattedValue = _formatValue(value, evt);
    if (evt.defaultPrevented) {
      evt.preventDefault();
      return;
    }
    const nextModel = formattedValue;
    updateModelValue(nextModel);
  };
  const onChange = (evt) => {
    const { value } = evt.target;
    const formattedValue = _formatValue(value, evt);
    if (evt.defaultPrevented) {
      evt.preventDefault();
      return;
    }
    const nextModel = formattedValue;
    if (modelValue.value !== nextModel) {
      updateModelValue(formattedValue, true);
    }
  };
  const onBlur = (evt) => {
    if (!modelModifiers.lazy && !props.lazyFormatter && !modelModifiers.trim) return;
    const { value } = evt.target;
    const formattedValue = _formatValue(value, evt, true);
    const nextModel = modelModifiers.trim ? formattedValue.trim() : formattedValue;
    const needsForceUpdate = nextModel.length !== formattedValue.length;
    if (modelValue.value !== nextModel) {
      updateModelValue(formattedValue, true);
    }
    if (modelModifiers.trim && needsForceUpdate) {
      forceUpdateKey.value = forceUpdateKey.value + 1;
    }
  };
  const focus = () => {
    if (!props.disabled) {
      focused.value = true;
    }
  };
  const blur = () => {
    if (!props.disabled) {
      focused.value = false;
    }
  };
  return {
    input,
    computedId,
    computedAriaInvalid,
    onInput,
    onChange,
    onBlur,
    focus,
    blur,
    forceUpdateKey
  };
};

// node_modules/bootstrap-vue-next/dist/useStateClass-BGbSLWFN.mjs
var useStateClass = (value) => computed(() => {
  const resolvedValue = toValue(value);
  return resolvedValue === true ? "is-valid" : resolvedValue === false ? "is-invalid" : null;
});

// node_modules/bootstrap-vue-next/dist/BFormInput.vue_vue_type_script_setup_true_lang-jvciEcJM.mjs
var _hoisted_1 = ["id", "value", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
var _sfc_main = defineComponent({
  __name: "BFormInput",
  props: mergeModels({
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazyFormatter: { type: Boolean, default: false },
    list: { default: void 0 },
    name: { default: void 0 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  }, {
    "modelValue": {
      default: ""
    },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose }) {
    const _props = __props;
    const props = useDefaults(_props, "BFormInput");
    const [modelValue, modelModifiers] = useModel(__props, "modelValue", {
      set: (v) => normalizeInput(v, modelModifiers)
    });
    const {
      input,
      computedId,
      computedAriaInvalid,
      onInput,
      onChange,
      onBlur,
      focus,
      blur,
      forceUpdateKey
    } = useFormInput(props, modelValue, modelModifiers);
    const stateClass = useStateClass(() => props.state);
    const computedClasses = computed(() => {
      const isRange = props.type === "range";
      const isColor = props.type === "color";
      return [
        stateClass.value,
        {
          "form-range": isRange,
          "form-control": isColor || !props.plaintext && !isRange,
          "form-control-color": isColor,
          "form-control-plaintext": props.plaintext && !isRange && !isColor,
          [`form-control-${props.size}`]: !!props.size
        }
      ];
    });
    __expose({
      blur,
      element: input,
      focus
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("input", {
        id: unref(computedId),
        ref_key: "input",
        ref: input,
        key: unref(forceUpdateKey),
        value: unref(modelValue),
        class: normalizeClass(computedClasses.value),
        name: unref(props).name || void 0,
        form: unref(props).form || void 0,
        type: unref(props).type,
        disabled: unref(props).disabled,
        placeholder: unref(props).placeholder,
        required: unref(props).required || void 0,
        autocomplete: unref(props).autocomplete || void 0,
        readonly: unref(props).readonly || unref(props).plaintext,
        min: unref(props).min,
        max: unref(props).max,
        step: unref(props).step,
        list: unref(props).type !== "password" ? unref(props).list : void 0,
        "aria-required": unref(props).required || void 0,
        "aria-invalid": unref(computedAriaInvalid),
        onInput: _cache[0] || (_cache[0] = //@ts-ignore
        (...args) => unref(onInput) && unref(onInput)(...args)),
        onChange: _cache[1] || (_cache[1] = //@ts-ignore
        (...args) => unref(onChange) && unref(onChange)(...args)),
        onBlur: _cache[2] || (_cache[2] = //@ts-ignore
        (...args) => unref(onBlur) && unref(onBlur)(...args))
      }, null, 42, _hoisted_1);
    };
  }
});

export {
  useAriaInvalid,
  useId2 as useId,
  normalizeInput,
  useFormInput,
  useStateClass,
  _sfc_main
};
//# sourceMappingURL=chunk-NHOLDF5O.js.map
